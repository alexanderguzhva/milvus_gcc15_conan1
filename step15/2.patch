diff --git a/internal/core/src/index/InvertedIndexTantivy.cpp b/internal/core/src/index/InvertedIndexTantivy.cpp
index c10cb42dcb..eef36ee846 100644
--- a/internal/core/src/index/InvertedIndexTantivy.cpp
+++ b/internal/core/src/index/InvertedIndexTantivy.cpp
@@ -506,7 +506,7 @@ InvertedIndexTantivy<T>::BuildWithRawDataForUT(size_t n,
             // only used in ut.
             auto arr = static_cast<const boost::container::vector<T>*>(values);
             for (size_t i = 0; i < n; i++) {
-                wrapper_->template add_array_data(
+                wrapper_->add_array_data(
                     arr[i].data(), arr[i].size(), i);
             }
         } else {
@@ -517,7 +517,7 @@ InvertedIndexTantivy<T>::BuildWithRawDataForUT(size_t n,
             // only used in ut.
             auto arr = static_cast<const boost::container::vector<T>*>(values);
             for (size_t i = 0; i < n; i++) {
-                wrapper_->template add_array_data_by_single_segment_writer(
+                wrapper_->add_array_data_by_single_segment_writer(
                     arr[i].data(), arr[i].size());
             }
         } else {
@@ -633,13 +633,13 @@ InvertedIndexTantivy<T>::build_index_for_array(
             }
             auto length = data->is_valid(i) ? array_column[i].length() : 0;
             if (!inverted_index_single_segment_) {
-                wrapper_->template add_array_data(
+                wrapper_->add_array_data(
                     reinterpret_cast<const ElementType*>(
                         array_column[i].data()),
                     length,
                     offset++);
             } else {
-                wrapper_->template add_array_data_by_single_segment_writer(
+                wrapper_->add_array_data_by_single_segment_writer(
                     reinterpret_cast<const ElementType*>(
                         array_column[i].data()),
                     length);
@@ -668,14 +668,14 @@ InvertedIndexTantivy<std::string>::build_index_for_array(
             std::vector<std::string> output;
             for (int64_t j = 0; j < array_column[i].length(); j++) {
                 output.push_back(
-                    array_column[i].template get_data<std::string>(j));
+                    array_column[i].get_data<std::string>(j));
             }
             auto length = data->is_valid(i) ? output.size() : 0;
             if (!inverted_index_single_segment_) {
-                wrapper_->template add_array_data(
+                wrapper_->add_array_data(
                     output.data(), length, offset++);
             } else {
-                wrapper_->template add_array_data_by_single_segment_writer(
+                wrapper_->add_array_data_by_single_segment_writer(
                     output.data(), length);
             }
         }
diff --git a/internal/core/src/segcore/storagev1translator/InterimSealedIndexTranslator.cpp b/internal/core/src/segcore/storagev1translator/InterimSealedIndexTranslator.cpp
index 3ad81c7474..06f67621a1 100644
--- a/internal/core/src/segcore/storagev1translator/InterimSealedIndexTranslator.cpp
+++ b/internal/core/src/segcore/storagev1translator/InterimSealedIndexTranslator.cpp
@@ -66,17 +66,17 @@ InterimSealedIndexTranslator::estimated_byte_size_of_cell(
                        knowhere::RefineType::BFLOAT16_QUANT) {
             vec_size += dim_ * 2;
         }  // else knowhere::RefineType::DATA_VIEW, no extra size
-        return {{vec_size * row_count, 0},
+        return {{static_cast<int64_t>(vec_size * row_count), 0},
                 {static_cast<int64_t>(vec_size * row_count + size * 0.5), 0}};
     } else if (index_type_ == knowhere::IndexEnum::INDEX_FAISS_IVFFLAT_CC) {
         // fp16/bf16 all use float32 to build index
         auto fp32_size = row_count * sizeof(float) * dim_;
-        return {{fp32_size, 0},
+        return {{static_cast<int64_t>(fp32_size), 0},
                 {static_cast<int64_t>(fp32_size + fp32_size * 0.5), 0}};
     } else {
         // SPARSE_WAND_CC and SPARSE_INVERTED_INDEX_CC basically has the same size as the
         // raw data.
-        return {{size, 0}, {static_cast<int64_t>(size * 2.0), 0}};
+        return {{static_cast<int64_t>(size), 0}, {static_cast<int64_t>(size * 2.0), 0}};
     }
 }
 
diff --git a/internal/core/src/segcore/storagev1translator/SealedIndexTranslator.cpp b/internal/core/src/segcore/storagev1translator/SealedIndexTranslator.cpp
index 4aca3d51d1..2008f7236a 100644
--- a/internal/core/src/segcore/storagev1translator/SealedIndexTranslator.cpp
+++ b/internal/core/src/segcore/storagev1translator/SealedIndexTranslator.cpp
@@ -75,8 +75,8 @@ SealedIndexTranslator::estimated_byte_size_of_cell(
             index_load_info_.num_rows,
             index_load_info_.dim);
     // this is an estimation, error could be up to 20%.
-    return {{request.final_memory_cost, request.final_disk_cost},
-            {request.max_memory_cost, request.max_disk_cost}};
+    return {{static_cast<int64_t>(request.final_memory_cost), static_cast<int64_t>(request.final_disk_cost)},
+            {static_cast<int64_t>(request.max_memory_cost), static_cast<int64_t>(request.max_disk_cost)}};
 }
 
 const std::string&
@@ -100,7 +100,7 @@ SealedIndexTranslator::get_cells(const std::vector<cid_t>& cids) {
             index_load_info_.enable_mmap,
             index_load_info_.num_rows,
             index_load_info_.dim);
-    index->SetCellSize({request.final_memory_cost, request.final_disk_cost});
+    index->SetCellSize({static_cast<int64_t>(request.final_memory_cost), static_cast<int64_t>(request.final_disk_cost)});
     if (index_load_info_.enable_mmap && index->IsMmapSupported()) {
         AssertInfo(!index_load_info_.mmap_dir_path.empty(),
                    "mmap directory path is empty");
